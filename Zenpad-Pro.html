<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>ZenPad Pro â€“ Crafted by Mohammed Sayyad (SayyadN)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Victor+Mono&family=Roboto:wght@400;500;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="static/websim-styles.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    :root {
  --bg-primary: #ffffff;
  --bg-secondary: #f8f9fa;
  --text-primary: #2d3436;
  --text-secondary: #636e72;
  --accent: #6c5ce7;
  --accent-gradient: linear-gradient(135deg, #6c5ce7, #8e44ad);
  --border-radius: 12px;
  --shadow: 0 12px 32px rgba(0,0,0,0.1);
  --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

[data-theme="dark"] {
  --bg-primary: #2d3436;
  --bg-secondary: #242a2c;
  --text-primary: #f8f9fa;
  --text-secondary: #adb5bd;
  --accent: #a592f2;
  --accent-gradient: linear-gradient(135deg, #a592f2, #6c5ce7);
}

[data-theme="sepia"] {
  --bg-primary: #f3e9d2;
  --bg-secondary: #e8dbbe;
  --text-primary: #3d3527;
  --text-secondary: #6b5e4a;
  --accent: #b88f4a;
  --accent-gradient: linear-gradient(135deg, #b88f4a, #f39c12);
}

* {
  box-sizing: border-box;
  touch-action: manipulation;
}

body {
  margin: 0;
  height: 100vh;
  background: var(--bg-secondary);
  font-family: 'Inter', sans-serif;
  overflow: hidden;
}

.container {
  display: flex;
  height: 100vh;
  background: var(--bg-primary);
  overflow: hidden;
}

.sidebar {
  width: 64px;
  background: var(--accent-gradient);
  border-right: 1px solid rgba(0,0,0,0.1);
  padding: 16px 0;
  display: flex;
  flex-direction: column;
  gap: 8px;
  transition: var(--transition);
  box-shadow: 2px 0 8px rgba(0,0,0,0.1);
}

.toolbar-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 0 8px;
}

.tool-button {
  width: 48px;
  height: 48px;
  border: none;
  background: var(--bg-primary);
  border-radius: var(--border-radius);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  color: var(--text-secondary);
  transition: var(--transition);
  position: relative;
  cursor: pointer;
}

.tool-button:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.tool-button.active {
  background: var(--accent);
  color: #fff;
}

.tool-button.active svg {
  transform: rotate(45deg);
  transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.tool-button span {
  font-size: 0.75rem;
  font-weight: 500;
}

.icon {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

.content-area {
  flex: 1;
  position: relative;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.note-editor-container {
  position: relative;
  height: 100%;
  display: flex;
  flex-direction: column;
  background: #fff;
  box-shadow: inset 0 0 12px rgba(0,0,0,0.05);
}

.tabs-container {
  display: flex;
  overflow-x: auto;
  background: var(--bg-secondary);
  border-bottom: 1px solid rgba(0,0,0,0.1);
}

.tab {
  padding: 8px 16px;
  cursor: pointer;
  border-right: 1px solid rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  justify-content: space-between;
  white-space: nowrap;
  user-select: none;
  transition: var(--transition);
}

.tab:hover {
  background: var(--accent-gradient);
  color: #fff;
}

.tab.active {
  background: var(--accent-gradient);
  color: #fff;
}

.tab .close-tab {
  margin-left: 8px;
  font-weight: bold;
}

#textEditor {
  flex: 1;
  width: 100%;
  min-height: 100%;
  padding: 16px;
  border: none;
  background: #fff;
  background-image: repeating-linear-gradient(
    to bottom,
    transparent,
    transparent calc(1.8em - 1px),
    rgba(0,0,0,0.1) calc(1.8em - 1px),
    rgba(0,0,0,0.1) 1.8em
  );
  font-family: 'Inter', sans-serif;
  font-size: 16px;
  line-height: 1.8;
  color: var(--text-primary);
  resize: none;
  overflow-y: auto;
  box-shadow: inset 0 0 8px rgba(0,0,0,0.05);
}

.notebook-lines {
  display: none;
}

.export-menu, .settings-menu {
  position: fixed;
  background: var(--bg-primary);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  padding: 8px;
  display: none;
  flex-direction: column;
  min-width: 200px;
  z-index: 1000;
  animation: fadeIn 0.3s ease-out;
}

.settings-menu {
  max-height: 60vh;
  overflow-y: auto;
  padding: 16px;
  gap: 12px;
  right: 16px;
  bottom: 72px;
}

.scrollable {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.setting-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 12px;
  background: var(--bg-secondary);
  border-radius: var(--border-radius);
}

.setting-group label {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-primary);
}

.attribution {
  position: fixed;
  bottom: 12px;
  right: 16px;
  font-size: 0.8rem;
  color: var(--text-secondary);
  background: var(--bg-primary);
  padding: 4px 8px;
  border-radius: 16px;
  box-shadow: var(--shadow);
  z-index: 1000;
  transition: var(--transition);
}

.attribution:hover {
  transform: scale(1.05);
}

.attribution span {
  font-weight: 600;
  color: var(--accent);
}

#drawWrapper {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: auto;
}

#drawCanvas {
  display: block;
  width: 100%;
  height: 100%;
  touch-action: none;
  background-color: var(--bg-primary);
  transition: background-color 0.2s ease;
  border: 1px solid rgba(0,0,0,0.05);
}

@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
}

@media (max-width: 768px) {
  .sidebar {
    width: 56px;
  }
  
  .tool-button {
    width: 40px;
    height: 40px;
  }
  
  #textEditor {
    padding: 24px;
    font-size: 14px;
  }
}

#textEditorToolbar {
  display: flex;
  gap: 8px;
  padding: 8px;
  background: var(--bg-secondary);
  border-bottom: 1px solid rgba(0,0,0,0.1);
}

#textEditorToolbar button {
  background: var(--bg-primary);
  border: none;
  border-radius: var(--border-radius);
  padding: 4px 8px;
  font-size: 0.9rem;
  color: var(--text-primary);
  cursor: pointer;
  transition: var(--transition);
}

#textEditorToolbar button:hover {
  background: var(--accent);
  color: #fff;
}

#chatContainer {
  display: none;
  height: calc(100% - 60px);
  overflow-y: auto;
  padding: 16px;
  background: #f1f1f1;
}

#chatInputWrapper {
  display: none;
  padding: 8px;
  border-top: 1px solid rgba(0,0,0,0.1);
  background: var(--bg-secondary);
  display: flex;
  align-items: center;
}

#chatInputWrapper input {
  flex: 1;
  padding: 8px;
  border: 1px solid rgba(0,0,0,0.2);
  border-radius: 4px;
}

#chatInputWrapper button {
  margin-left: 8px;
  padding: 8px 16px;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: var(--transition);
}

#chatInputWrapper button:hover {
  background: var(--accent-gradient);
}

.chat-message {
  margin-bottom: 16px;
  padding: 8px;
  border-radius: var(--border-radius);
  max-width: 80%;
}

.chat-message.user {
  background: var(--accent-gradient);
  color: #fff;
  align-self: flex-end;
  margin-left: auto;
}

.chat-message.ai {
  background: var(--bg-primary);
  color: var(--text-primary);
  align-self: flex-start;
  margin-right: auto;
}
  </style>
</head>
<body data-theme="light">
  <div class="container">
    <nav class="sidebar">
      <div class="toolbar-group">
        <button class="tool-button" onclick="setMode('text')" id="textBtn">
          <svg class="icon" viewBox="0 0 24 24"><path d="M4 20v-6h16v6H4zm0-8l7-7 7 7H4z"/></svg>
          <span>Text</span>
        </button>
        <button class="tool-button" onclick="setMode('draw')" id="drawBtn">
          <svg class="icon" viewBox="0 0 24 24"><path d="M6 21q-.825 0-1.412-.587Q4 19.825 4 19V5q0-.825.588-1.413Q5.175 3 6 3h12q.825 0 1.413.587Q20 4.175 20 5v14q0 .825-.587 1.413Q18.825 21 18 21Zm0-2h12V5H6v14Zm3-1h6q.425 0 .713-.288Q16 17.425 16 17t-.287-.712Q15.425 16 15 16H9q-.425 0-.712.288Q8 16.575 8 17t.288.712Q8.575 18 9 18Zm-3 1V5v14Z"/></svg>
          <span>Draw</span>
        </button>
        <button class="tool-button" onclick="toggleEraser()" id="eraserBtn">
          <svg class="icon" viewBox="0 0 24 24"><path d="M16.9 21 10 13.95 12.95 11l6.9 6.95-2.95 2.95Zm-6.95-6.95-4.25-4.2L12.95 3H20v7.05L17.05 13l-7 7.05Z"/></svg>
          <span>Eraser</span>
        </button>
        <button class="tool-button" onclick="clearDrawing()" id="clearDrawBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M3 6h18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
            <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
            <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
            <path d="M10 11v6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
            <path d="M14 11v6" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round"/>
          </svg>
          <span>Clear</span>
        </button>
      </div>

      <div class="toolbar-group scrollable">
        <button class="tool-button" onclick="showExportMenu()">
          <svg class="icon" viewBox="0 0 24 24"><path d="M14 17v-4h-4v4H5l7-7 7 7h-5ZM5 20q-.825 0-1.413-.587Q3 18.825 3 18v-3h2v3h14v-3h2v3q0 .825-.587 1.413Q19.825 20 19 20Z"/></svg>
          <span>Export</span>
        </button>
        <button class="tool-button" onclick="showSettings()">
          <svg class="icon" viewBox="0 0 24 24"><path d="m9.25 22-.4-3.2q-.325-.125-.612-.3-.288-.175-.563-.375L4.7 19.375l-2.75-4.75 2.575-1.95Q4.5 12.5 4.5 12.337v-.674q0-.163.025-.338L1.95 9.375l2.75-4.75 2.975 1.25q.275-.2.575-.375.3-.175.6-.3l.4-3.2h5.5l.4 3.2q.325.125.613.3.287.175.562.375l2.975-1.25 2.75 4.75-2.575 1.95q.025.175.025.338v.674q0 .163-.05.338l2.575 1.95-2.75 4.75-2.95-1.25q-.275.2-.562.375-.288.175-.613.3l-.4 3.2Zm2.8-6.5q1.45 0 2.475-1.025Q15.55 12.95 15.55 11.5q0-1.45-1.025-2.475Q13.5 8 12.05 8q-1.45 0-2.475 1.025Q8.55 10.05 8.55 11.5q0 1.45 1.025 2.475Q10.6 15 12.05 15Z"/></svg>
          <span>Settings</span>
        </button>
      </div>
    </nav>

    <div class="content-area">
      <!-- Text Note Container with Tabs, Text Formatting Toolbar, and AI Chat -->
      <div id="textNoteContainer" class="note-editor-container">
        <div id="notesTabs" class="tabs-container"></div>
        <div id="textEditorToolbar" class="toolbar">
          <button onclick="applyFormatting('h1')">H1</button>
          <button onclick="applyFormatting('h2')">H2</button>
          <button onclick="applyFormatting('h3')">H3</button>
          <button onclick="applyFormatting('ul')">Bullet</button>
          <button onclick="applyFormatting('quote')">Quote</button>
          <button onclick="applyFormatting('bold')">Bold</button>
          <button onclick="applyFormatting('italic')">Italic</button>
        </div>
        <textarea id="textEditor" placeholder="Start writing..."></textarea>
        <!-- AI Chat Container (hidden by default) -->
        <div id="chatContainer"></div>
        <div id="chatInputWrapper">
          <input type="text" id="chatInput" placeholder="Type your message...">
          <button onclick="sendChatMessage()">Send</button>
        </div>
      </div>
      <!-- Drawing Canvas Wrapper for infinite scroll in all directions -->
      <div id="drawWrapper" style="display: none;">
        <canvas id="drawCanvas"></canvas>
      </div>
    </div>

    <div class="export-menu">
      <button class="menu-item" onclick="exportContent('txt')">Text (.txt)</button>
      <button class="menu-item" onclick="exportContent('pdf')">PDF</button>
      <button class="menu-item" onclick="exportContent('png')">Image</button>
      <button class="menu-item" onclick="exportContent('svg')">Vector</button>
      <button class="menu-item" onclick="hideExportMenu()">Close</button>
    </div>

    <div class="settings-menu scrollable">
      <div class="setting-group">
        <label>Theme</label>
        <select id="themeSelect" onchange="toggleTheme(this.value)">
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="sepia">Sepia</option>
        </select>
      </div>
      <div class="setting-group">
        <label>Line Spacing:</label>
        <input type="range" id="lineSpacing" min="20" max="50" value="30" oninput="updateLineCount(this.value)">
        <span id="lineCountValue" style="color: var(--text-primary)">30px</span>
      </div>

      <div class="setting-group">
        <label>Line Color:</label>
        <input type="color" value="#000000" oninput="updateLineColor(this.value)">
      </div>

      <div class="setting-group">
        <label>Editor Font:</label>
        <select id="fontSelect" onchange="updateFont(this.value)">
          <option value="Inter">Inter (Sans Serif)</option>
          <option value="Victor Mono">Victor Mono (Monospace)</option>
          <option value="Roboto">Roboto</option>
          <option value="Lato">Lato</option>
        </select>
        <div class="font-preview" id="fontPreview">
          The quick brown fox jumps over the lazy dog
        </div>
      </div>

      <div class="setting-group">
        <label>Line Height:</label>
        <input type="range" id="lineHeight" min="1.4" max="2.4" step="0.2" oninput="updateLineHeight(this.value)">
        <span id="lineHeightValue" style="color: var(--text-primary)">1.8</span>
      </div>

      <div class="setting-group">
        <label>Page Margins:</label>
        <input type="range" id="pageMargins" min="10" max="50" oninput="updateMargins(this.value)">
        <span id="marginValue" style="color: var(--text-primary)">20px</span>
      </div>

      <div class="setting-group">
        <label>Text Color:</label>
        <input type="color" id="textColor" value="#333333" onchange="updateTextColor(this.value)">
      </div>

      <div class="setting-group">
        <label>Drawing Color:</label>
        <input type="color" id="drawColor" value="#000000" onchange="updateDrawingColor(this.value)">
      </div>

      <div class="setting-group">
        <label>Brush Size:</label>
        <input type="range" id="brushSize" min="1" max="50" value="3" oninput="updateBrushSize(this.value)">
        <span id="brushSizeValue">3</span>
      </div>

      <button onclick="hideSettings()">Close Preferences</button>
    </div>

    <div class="attribution">
      Crafted by <span>Mohammed Sayyad</span> (SayyadN)
    </div>
  </div>
  <!-- Coordinate display for drawing canvas -->
  <div id="coordDisplay"></div>
  
  <button id="backToTopBtn" title="Back to Top" onclick="scrollToTop()">
    <svg class="icon" viewBox="0 0 24 24" style="width:24px; height:24px;">
      <path d="M12 4l-8 8h6v8h4v-8h6z" fill="currentColor"/>
    </svg>
  </button>
  
  <script src="static/draw-handler.js"></script>
  <script src="static/text-formatter.js"></script>
  <script src="static/ai-chat.js"></script>
  <script>
    let drawingManager, currentMode = 'text';
    let scale = 1, panX = 0, panY = 0;
    
    function setCanvasTransform() {
      const canvas = document.getElementById('drawCanvas');
      canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }
    
    function handleZoom(e) {
      e.preventDefault();
      const delta = e.deltaY * -0.001;
      scale = Math.min(Math.max(1, scale + delta), 5);
      setCanvasTransform();
    }
    
    function toggleTheme(theme) {
      document.body.setAttribute('data-theme', theme);
      localStorage.setItem('smartpad-settings', JSON.stringify({ theme }));
      document.getElementById('themeSelect').value = theme;
    }
    
    function initTheme() {
      const saved = localStorage.getItem('smartpad-settings');
      if(saved) {
        const savedSettings = JSON.parse(saved);
        toggleTheme(savedSettings.theme || 'light');
      }
    }
    
    function setMode(mode) {
      currentMode = mode;
      document.querySelectorAll('.tool-button').forEach(btn => 
        btn.classList.toggle('active', btn.id === mode+'Btn'));
      document.getElementById('textNoteContainer').style.display = mode === 'text' ? 'block' : 'none';
      document.getElementById('drawWrapper').style.display = mode === 'draw' ? 'block' : 'none';
      drawingManager?.resizeCanvas();
    }
    
    function updateLineCount(value) {
      document.documentElement.style.setProperty('--line-spacing', value + 'px');
      document.getElementById('lineCountValue').textContent = value + 'px';
    }
    
    function updateLineColor(color) {
      document.documentElement.style.setProperty('--line-color', color + '20');
    }
    
    function updateFont(font) {
      document.getElementById('textEditor').style.fontFamily = font;
      document.getElementById('fontPreview').style.fontFamily = font;
    }
    
    function updateLineHeight(value) {
      document.getElementById('textEditor').style.lineHeight = value;
      document.getElementById('lineHeightValue').textContent = value;
    }
    
    function updateMargins(value) {
      document.getElementById('textEditor').style.padding = value + 'px';
      document.getElementById('marginValue').textContent = value + 'px';
    }
    
    function updateTextColor(color) {
      document.getElementById('textEditor').style.color = color;
    }
    
    function updateDrawingColor(color) {
      drawingManager.updateBrushSettings(color, parseInt(document.getElementById('brushSize').value));
      document.getElementById('drawColor').value = color;
    }
    
    function updateBrushSize(value) {
      drawingManager.updateBrushSettings(document.getElementById('drawColor').value, parseInt(value));
      document.getElementById('brushSizeValue').textContent = value;
    }
    
    function toggleEraser() {
      if(drawingManager) drawingManager.toggleEraser();
    }
    
    function clearDrawing() {
      if(drawingManager) drawingManager.clearAll();
    }
    
    function showExportMenu() {
      document.querySelector('.export-menu').style.display = 'flex';
    }
    
    function hideExportMenu() {
      document.querySelector('.export-menu').style.display = 'none';
    }
    
    function exportContent(format) {
      let activeNote = notes.find(n => n.id === currentNoteId);
      let defaultName = activeNote ? activeNote.title : `ZenPad_${new Date().toISOString().slice(0,10)}`;
      const fileName = prompt('Enter file name:', defaultName);
      if(!fileName) return;
      hideExportMenu();
      const drawWrapper = document.getElementById('drawWrapper');
      const canvas = document.getElementById('drawCanvas');
      const dpr = window.devicePixelRatio || 1;
      
      switch (format) {
        case 'txt': {
          let textContent = "";
          if (activeNote && activeNote.id === 'ai-chat') {
            // Export AI chat conversation with notebook style numbering
            const chatMessages = document.getElementById('chatContainer').querySelectorAll('.chat-message');
            chatMessages.forEach((msg, index) => {
              const sender = msg.classList.contains('user') ? 'User' : 'AI';
              const lineNumber = (index + 1).toString().padStart(3, ' ');
              textContent += `${lineNumber} â”‚ [${sender}] ${msg.innerText}\n`;
            });
          } else {
            textContent = activeNote ? activeNote.content : document.getElementById('textEditor').value;
            const lines = textContent.split('\n');
            textContent = lines.map((line, index) => {
              const lineNumber = (index + 1).toString().padStart(3, ' ');
              return `${lineNumber} â”‚ ${line}`;
            }).join('\n');
          }
          // Add BOM for UTF-8 and specify charset to properly support Arabic
          const blob = new Blob(["\uFEFF" + textContent], { type: 'text/plain;charset=utf-8' });
          downloadBlob(blob, `${fileName}.txt`);
          break;
        }
        case 'pdf': {
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF();
          let text = "";
          if (activeNote && activeNote.id === 'ai-chat') {
            const chatMessages = document.getElementById('chatContainer').querySelectorAll('.chat-message');
            chatMessages.forEach(msg => {
              const sender = msg.classList.contains('user') ? 'User' : 'AI';
              text += `[${sender}] ${msg.innerText}\n\n`;
            });
          } else {
            text = activeNote ? activeNote.content : document.getElementById('textEditor').value;
          }
          const lines = text.split('\n');
          let yPos = 15;
          const defaultFontSize = 12;
          lines.forEach(line => {
            let alignment = 'left';
            let content = line;
            if (isArabic(line)) {
              content = processArabic(line);
              alignment = 'right';
            }
            if (line.startsWith('# ')) {
              pdf.setFontSize(20);
              let heading = line.substring(2).trim();
              if (isArabic(heading)) {
                heading = processArabic(heading);
                alignment = 'right';
              }
              pdf.text(heading, alignment === 'right' ? pdf.internal.pageSize.getWidth() - 15 : 15, yPos, { maxWidth: 180, align: alignment });
              yPos += 20 * 1.5;
            } else {
              pdf.setFontSize(defaultFontSize);
              pdf.text(content, alignment === 'right' ? pdf.internal.pageSize.getWidth() - 15 : 15, yPos, { maxWidth: 180, align: alignment });
              yPos += defaultFontSize * 1.5;
            }
          });
          pdf.setDrawColor(200);
          for (let y = 10; y < yPos + 10; y += 10) {
            pdf.line(10, y, 200, y);
          }
          if(currentMode === 'draw') {
            const imgData = canvas.toDataURL('image/png');
            const imgProps = pdf.getImageProperties(imgData);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
            pdf.addPage();
            pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
          }
          pdf.save(`${fileName}.pdf`);
          break;
        }
        case 'png': {
          const fullCanvas = document.createElement('canvas');
          const ctx = fullCanvas.getContext('2d');
          fullCanvas.width = canvas.width;
          fullCanvas.height = canvas.height;
          ctx.drawImage(canvas, 0, 0);
          fullCanvas.toBlob(blob => {
            downloadBlob(blob, `${fileName}.png`);
          }, 'image/png');
          break;
        }
        case 'svg': {
          const svgContent = drawingManager.getStrokes().map(stroke => 
            `<path d="M${stroke.points.map(p => `${p.x/dpr} ${p.y/dpr}`).join(' L')}" 
              stroke="${stroke.color}" 
              stroke-width="${stroke.width/dpr}" 
              transform="translate(${panX} ${panY}) scale(${1/scale})"
              fill="none"
              stroke-linecap="round"/>`
          ).join('');
          const svg = `<svg xmlns="http://www.w3.org/2000/svg" 
            viewBox="0 0 ${canvas.width/dpr} ${canvas.height/dpr}"
            width="${canvas.width/dpr}px" 
            height="${canvas.height/dpr}px">${svgContent}</svg>`;
          const blob = new Blob([svg], { type: 'image/svg+xml' });
          downloadBlob(blob, `${fileName}.svg`);
          break;
        }
      }
    }
    
    function downloadBlob(blob, filename) {
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    // Helper functions to support proper Arabic text display in exports
    function isArabic(text) {
      return /[\u0600-\u06FF]/.test(text);
    }
    function processArabic(text) {
      // Naively reverse the text to support right-to-left display.
      // (For production, consider using a proper Arabic reshaper.)
      return text.split('').reverse().join('');
    }
    
    let isPanning = false;
    let lastX = 0;
    let lastY = 0;
    
    window.addEventListener('DOMContentLoaded', () => {
      initTheme(); 
      const canvas = document.getElementById('drawCanvas');
      // Initially allocate a larger internal canvas.
      canvas.width = window.innerWidth * 2;
      canvas.height = window.innerHeight * 2;
      drawingManager = new DrawingManager(canvas);
      drawingManager.updateEraserButton();
      canvas.style.touchAction = 'none';
      const savedDrawSettings = localStorage.getItem('drawSettings');
      if(savedDrawSettings) {
        const {color, width} = JSON.parse(savedDrawSettings);
        document.getElementById('drawColor').value = color;
        document.getElementById('brushSize').value = width;
        document.getElementById('brushSizeValue').textContent = width;
      }
      if(drawingManager.settings.isEraser) {
        document.getElementById('eraserBtn').classList.add('active');
      }
      
      canvas.addEventListener('wheel', handleZoom);
      
      canvas.addEventListener('pointermove', (e) => {
        const rect = e.target.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left) / scale);
        const y = Math.round((e.clientY - rect.top) / scale);
        const coordDisplay = document.getElementById('coordDisplay');
        if (coordDisplay) {
          coordDisplay.innerText = `X: ${x}, Y: ${y}`;
        }
      });
    });
    
    window.addEventListener('resize', () => drawingManager?.resizeCanvas());
    
    window.addEventListener('mouseup', () => isPanning = false);
    
    document.getElementById('drawCanvas').addEventListener('mousedown', (e) => {
      if (e.button === 1) { 
        isPanning = true;
        lastX = e.clientX;
        lastY = e.clientY;
      }
    });
    
    window.addEventListener('mousemove', (e) => {
      if (isPanning) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        const contentArea = document.querySelector('.content-area');
        contentArea.scrollBy(-deltaX*2, -deltaY*2);
        lastX = e.clientX;
        lastY = e.clientY;
      }
    });
    
    document.getElementById('drawCanvas').addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    });
    
    document.getElementById('drawCanvas').addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        const deltaX = e.touches[0].clientX - touchStartPos.x;
        const deltaY = e.touches[0].clientY - touchStartPos.y;
        const contentArea = document.querySelector('.content-area');
        contentArea.scrollLeft -= deltaX*2;
        contentArea.scrollTop -= deltaY*2;
        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    });
    
    let touchStartPos = { x: 0, y: 0 };
    
    const textEditor = document.getElementById('textEditor');
    textEditor.addEventListener('input', function () {
      this.style.height = 'auto';
      this.style.height = this.scrollHeight + 'px';
    });
    
    textEditor.addEventListener('scroll', function() {
      const threshold = 200;
      const scrollBottom = this.scrollHeight - (this.scrollTop + this.clientHeight);
      if(scrollBottom < threshold) {
        const currentPadding = parseInt(getComputedStyle(this).paddingBottom) || 0;
        this.style.paddingBottom = `${currentPadding + 1000}px`;
      }
    });
    
    function showSettings() {
      document.querySelector('.settings-menu').style.display = 'flex';
    }
    
    function hideSettings() {
      document.querySelector('.settings-menu').style.display = 'none';
    }
    
    let notes = [
      { id: 'note1', title: 'Note 1', content: '' },
      { id: 'ai-chat', title: 'AI Chat', content: '' }
    ];
    let currentNoteId = 'note1';
    
    function updateTabsUI() {
      const tabsContainer = document.getElementById('notesTabs');
      tabsContainer.innerHTML = '';
      notes.forEach(note => {
        const tab = document.createElement('div');
        tab.classList.add('tab');
        if (note.id === currentNoteId) tab.classList.add('active');
        tab.textContent = note.title;
        tab.dataset.id = note.id;
        if (notes.length > 1 && note.id !== 'ai-chat') {
          const closeBtn = document.createElement('span');
          closeBtn.textContent = 'âœ•';
          closeBtn.classList.add('close-tab');
          closeBtn.onclick = (e) => {
            e.stopPropagation();
            removeNote(note.id);
          };
          tab.appendChild(closeBtn);
        }
        tab.onclick = () => { switchNote(note.id); };
        tabsContainer.appendChild(tab);
      });
      const addTab = document.createElement('div');
      addTab.classList.add('tab');
      addTab.textContent = '+';
      addTab.onclick = addNote;
      tabsContainer.appendChild(addTab);
    }
    
    function switchNote(id) {
      saveCurrentNote();
      currentNoteId = id;
      const note = notes.find(n => n.id === currentNoteId);
      updateTabsUI();
      if (note.id === 'ai-chat') {
        document.getElementById('textEditorToolbar').style.display = 'none';
        document.getElementById('textEditor').style.display = 'none';
        document.getElementById('chatContainer').style.display = 'block';
        document.getElementById('chatInputWrapper').style.display = 'flex';
      } else {
        document.getElementById('textEditorToolbar').style.display = 'flex';
        document.getElementById('textEditor').style.display = 'block';
        document.getElementById('chatContainer').style.display = 'none';
        document.getElementById('chatInputWrapper').style.display = 'none';
        document.getElementById('textEditor').value = note ? note.content : '';
      }
    }
    
    function addNote() {
      saveCurrentNote();
      const newId = 'note' + (notes.length);
      const newNote = { id: newId, title: `Note ${notes.length}`, content: '' };
      notes.push(newNote);
      currentNoteId = newId;
      document.getElementById('textEditor').value = '';
      updateTabsUI();
    }
    
    function removeNote(id) {
      if (notes.length <= 1) return;
      notes = notes.filter(n => n.id !== id);
      if (currentNoteId === id) {
        currentNoteId = notes[0].id;
        document.getElementById('textEditor').value = notes[0].content;
      }
      updateTabsUI();
    }
    
    function saveCurrentNote() {
      const note = notes.find(n => n.id === currentNoteId);
      if (!note) return;
      if (note.id === 'ai-chat') return;
      note.content = document.getElementById('textEditor').value;
    }
    
    document.getElementById('textEditor').addEventListener('input', saveCurrentNote);
    updateTabsUI();
    
    function scrollToTop() {
      document.querySelector('.content-area').scrollTo({
        top: 0,
        left: 0,
        behavior: 'smooth'
      });
    }
  </script>
  <script>
    (function() {
  'use strict';
  
  // Append a chat message to the chat container.
  window.appendChatMessage = function(sender, message) {
    const chatContainer = document.getElementById('chatContainer');
    if (!chatContainer) return;
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('chat-message');
    messageDiv.classList.add(sender.toLowerCase());
    messageDiv.innerText = message;
    chatContainer.appendChild(messageDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
  };

  // Send the user's chat message and fetch an AI response using the provided Google API key and model.
  window.sendChatMessage = async function() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    if (!message) return;
    appendChatMessage('User', message);
    chatInput.value = '';
    
    // Intercept "Who are you?" queries to provide a multilingual answer.
    if (/^\s*who\s+are\s+you\s*\??\s*$/i.test(message)) {
      const responses = [
        "English: I was created by Mohammed Sayyad (SayyadN).",
        "EspaÃ±ol: Fui creado por Mohammed Sayyad (SayyadN).",
        "FranÃ§ais: J'ai Ã©tÃ© crÃ©Ã© par Mohammed Sayyad (SayyadN).",
        "Deutsch: Ich wurde von Mohammed Sayyad (SayyadN) erstellt.",
        "Italiano: Sono stato creato da Mohammed Sayyad (SayyadN).",
        "PortuguÃªs: Fui criado por Mohammed Sayyad (SayyadN)."
      ];
      const answer = responses.join("\n");
      appendChatMessage('AI', answer);
      return;
    }
    
    try {
      const response = await fetch('/api/ai_completion', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          prompt: message,
          apiKey: "AIzaSyAAz3dvPFaZ4_BVAcjEbLf2cWCTrfAzviQ",
          model: "gemini-1.5-flash"
        })
      });
      const json = await response.json();
      const aiResponse = json.response || "AI did not respond.";
      appendChatMessage('AI', aiResponse);
    } catch (err) {
      console.error(err);
      appendChatMessage('AI', "Error occurred while getting AI response.");
    }
  };

  // Enable sending a chat message by pressing the Enter key.
  document.addEventListener('DOMContentLoaded', function() {
    const chatInput = document.getElementById('chatInput');
    if(chatInput) {
      chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendChatMessage();
        }
      });
    }
  });
})();
  </script>
  <script>
    class DrawingManager {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d', { willReadFrequently: true });
    this.undoStack = [];
    this.currentPath = null;
    this.settings = {
      color: '#000000',
      width: 3,
      isEraser: false,
      baseColor: getComputedStyle(canvas).backgroundColor
    };
    this.init();
  }

  init() {
    this.resizeCanvas();
    this.setupInputHandling();
    window.addEventListener('resize', () => this.resizeCanvas());
    
    const savedSettings = localStorage.getItem('drawSettings');
    if (savedSettings) {
      Object.assign(this.settings, JSON.parse(savedSettings));
    }
    this.updateEraserButton();
  }

  updateEraserButton() {
    const eraserBtn = document.getElementById('eraserBtn');
    if (eraserBtn) {
      eraserBtn.classList.toggle('active', this.settings.isEraser);
      eraserBtn.querySelector('svg').style.transform = this.settings.isEraser ? 'rotate(45deg)' : 'none';
    }
  }

  toggleEraser() {
    this.settings.isEraser = !this.settings.isEraser;
    this.settings.color = this.settings.isEraser 
      ? this.settings.baseColor 
      : document.getElementById('drawColor').value;
    this.updateEraserButton();
    localStorage.setItem('drawSettings', JSON.stringify(this.settings));
  }

  setupInputHandling() {
    const getScaledPoint = (clientX, clientY) => {
      const rect = this.canvas.getBoundingClientRect();
      const contentArea = this.canvas.parentElement.parentElement; 
      return {
        x: (clientX - rect.left + contentArea.scrollLeft) / (rect.width / this.canvas.width),
        y: (clientY - rect.top + contentArea.scrollTop) / (rect.height / this.canvas.height)
      };
    };

    const handleStart = (clientX, clientY) => {
      const { x, y } = getScaledPoint(clientX, clientY);
      this.currentPath = {
        points: [{ x, y }],
        color: this.settings.isEraser ? this.settings.baseColor : this.settings.color,
        width: this.settings.width,
        compositeOp: this.settings.isEraser ? 'destination-out' : 'source-over'
      };
      this.undoStack.push(this.currentPath);
    };

    const handleMove = (clientX, clientY) => {
      if (!this.currentPath) return;
      
      const { x, y } = getScaledPoint(clientX, clientY);
      const padding = 100;
      const expand = { left: 0, right: 0, top: 0, bottom: 0 };

      if (x < padding) expand.left = padding - x;
      else if (x > this.canvas.width - padding) 
        expand.right = x - (this.canvas.width - padding);

      if (y < padding) expand.top = padding - y;
      else if (y > this.canvas.height - padding)
        expand.bottom = y - (this.canvas.height - padding);

      if (expand.left + expand.right + expand.top + expand.bottom > 0) {
        this.expandCanvas(expand.left, expand.right, expand.top, expand.bottom);
      }

      this.currentPath.points.push({ x, y });
      this.redraw();
    };

    const handleEnd = () => {
      this.currentPath = null;
    };

    const handleEvent = (e) => {
      if (e.pointerType === 'touch') {
        e.preventDefault();
      }
    };

    this.canvas.addEventListener('pointerdown', e => {
      handleEvent(e);
      handleStart(e.clientX, e.clientY);
    });

    this.canvas.addEventListener('pointermove', e => {
      handleEvent(e);
      handleMove(e.clientX, e.clientY);
    });

    ['pointerup', 'pointercancel'].forEach(event => {
      this.canvas.addEventListener(event, e => {
        handleEvent(e);
        handleEnd();
      });
    });

    this.canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      this.toggleEraser();
    });
  }

  expandCanvas(left, right, top, bottom) {
    const dpr = window.devicePixelRatio;
    const wrapper = this.canvas.parentElement; 
    const currentCSSWidth = wrapper.clientWidth;
    const currentCSSHeight = wrapper.clientHeight;

    const newCSSWidth = currentCSSWidth + left + right;
    const newCSSHeight = currentCSSHeight + top + bottom;

    if (wrapper) {
      wrapper.style.width = newCSSWidth + 'px';
      wrapper.style.height = newCSSHeight + 'px';
    }

    const scrollContainer = wrapper.parentElement; 
    if (left > 0) scrollContainer.scrollLeft = 0;
    else if (right > 0) scrollContainer.scrollLeft = newCSSWidth - scrollContainer.clientWidth;
    if (top > 0) scrollContainer.scrollTop = 0;
    else if (bottom > 0) scrollContainer.scrollTop = newCSSHeight - scrollContainer.clientHeight;

    const newWidth = newCSSWidth * dpr;
    const newHeight = newCSSHeight * dpr;

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = newWidth;
    tempCanvas.height = newHeight;
    const tempCtx = tempCanvas.getContext('2d');

    const shiftX = left * dpr;
    const shiftY = top * dpr;
    tempCtx.drawImage(this.canvas, shiftX, shiftY);

    this.canvas.width = newWidth;
    this.canvas.height = newHeight;
    this.ctx.drawImage(tempCanvas, 0, 0);

    if (left > 0 || top > 0) {
      this.undoStack.forEach(path => {
        path.points.forEach(p => {
          p.x += left;
          p.y += top;
        });
      });
    }
    this.redraw();
  }

  redraw() {
    this.ctx.save();
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.ctx.fillStyle = getComputedStyle(this.canvas).backgroundColor;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    this.undoStack.forEach(path => {
      this.ctx.beginPath();
      this.ctx.globalCompositeOperation = path.compositeOp;
      this.ctx.strokeStyle = path.color;
      this.ctx.lineWidth = path.width;
      this.ctx.lineCap = 'round';
      this.ctx.lineJoin = 'round';
      
      path.points.forEach((p, i) => {
        if (i === 0) this.ctx.moveTo(p.x, p.y);
        else this.ctx.lineTo(p.x, p.y);
      });
      this.ctx.stroke();
    });
    this.ctx.restore();
  }

  updateBrushSettings(color, width) {
    this.settings.color = color;
    this.settings.width = width;
    localStorage.setItem('drawSettings', JSON.stringify(this.settings));
  }

  resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.getBoundingClientRect();
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    this.ctx.scale(dpr, dpr);
    this.redraw();
  }

  getStrokes() {
    return this.undoStack;
  }
  
  clearAll() {
    this.undoStack = [];
    this.redraw();
  }
}

window.DrawingManager = DrawingManager;
  </script>
  <script>
    (function() {
  'use strict';

  // Applies formatting commands to the text editor content.
  // For example, clicking the H1 button inserts "# " at the beginning of the line;
  // when exported (e.g. as PDF), lines starting with "# " are rendered with a larger font.
  window.applyFormatting = function(format) {
    const textarea = document.getElementById('textEditor');
    if (!textarea) return;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const originalText = textarea.value;
    let modifiedText = originalText;

    switch(format) {
      case 'h1':
        modifiedText = insertAtLineStart(originalText, start, end, '# ');
        break;
      case 'h2':
        modifiedText = insertAtLineStart(originalText, start, end, '## ');
        break;
      case 'h3':
        modifiedText = insertAtLineStart(originalText, start, end, '### ');
        break;
      case 'bold':
        modifiedText = wrapSelection(originalText, start, end, '**');
        break;
      case 'italic':
        modifiedText = wrapSelection(originalText, start, end, '*');
        break;
      case 'ul':
        modifiedText = insertAtLineStart(originalText, start, end, '- ');
        break;
      case 'quote':
        modifiedText = insertAtLineStart(originalText, start, end, '> ');
        break;
      default:
        break;
    }

    textarea.value = modifiedText;
    textarea.focus();
  };

  // Wraps the selected text with the specified wrapper (e.g., ** for bold)
  function wrapSelection(text, start, end, wrapper) {
    const selected = text.substring(start, end);
    return text.substring(0, start) + wrapper + selected + wrapper + text.substring(end);
  }

  // Inserts a prefix at the start of each line in the selected area.
  function insertAtLineStart(text, start, end, prefix) {
    let lineStart = text.lastIndexOf('\n', start - 1);
    lineStart = (lineStart === -1) ? 0 : lineStart + 1;
    let lineEnd = text.indexOf('\n', end);
    lineEnd = (lineEnd === -1) ? text.length : lineEnd;
    const selectedBlock = text.substring(lineStart, lineEnd);
    const lines = selectedBlock.split('\n');
    const formattedLines = lines.map(line => {
      return line.startsWith(prefix) ? line : prefix + line;
    });
    return text.substring(0, lineStart) + formattedLines.join('\n') + text.substring(lineEnd);
  }
})();
  </script>
  <script>
    
  </script>
</body>
</html>
